##
## File            : $File$
## SCM             : $URL$
##
## Copyright       : Realworld Systems
##                   e-mail  : support@realworld-systems.com
##                   address : Venusstraat 17, 4105 JH Culemborg, The Netherlands
##                   tel     : +31(0)345 614406
##                   fax     : +31(0)345 614319
##
## Contains        : 
##
##
## Date written    : 2014-12-24
## Date changed    : $Date$
## Revision        : $Rev$

_package rwan
$

#remex(:distance_filter_collection)

_pragma(classify_level=basic, topic={analysis})
##
## Collection that performs a distance test on a geometry
## field of the base collection to the given spatial
## argument. This collection assumes that .arg is a somewhat
## large collection. If .arg is not, then you rather should use distance_area_filter_collection
def_slotted_exemplar(:distance_filter_collection,
	{
		{:geom_name,  _unset},
		{:distance,   _unset},
		{:arg,        _unset},
		{:inverse?, _unset}
	}, :base_record_collection)
$


_pragma(classify_level=basic, topic={analysis})
_method distance_filter_collection.new(dsm, base_col, geom_name, distance, arg,  inverse?)
	_return _clone.init(dsm, base_col, geom_name, distance, arg, inverse?)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_private _method distance_filter_collection.init(dsm, base_col, geom_name, distance, arg,  inverse?)
	.geom_name << geom_name
	.distance << distance
	.arg << arg
	.inverse? << inverse?
	_return _super.init(dsm, base_col)
_endmethod
$

_pragma(classify_level=restricted, topic={demo})
_method distance_filter_collection.serial_slots()
	_local (keys, values) << _super.serial_slots()
	keys.add_all_last(  {:geom_name, :distance, :arg, :inverse?})
	values.add_all_last({.geom_name, .distance, .arg, .inverse?})
	_return keys, values
_endmethod
$

_pragma(classify_level=restricted, topic={demo})
_private _method distance_filter_collection.init_from_serial(dsm, base_cols, geom_name, distance, arg, inverse?)
    _super.init_from_serial(dsm, base_cols)
    .geom_name << geom_name
    .distance << distance
    .arg << arg
    .inverse? << inverse?
    _return _self 
_endmethod
$

_pragma(classify_level=restricted, topic={demo})
_private _method distance_filter_collection.single_strategy?
	_return .arg.convert_to_geometry_is_fast?
_endmethod
$

_pragma(classify_level=basic, topic={demo})
_method distance_filter_collection.base_collections
	_return {_self.base_collection, .arg}
_endmethod
$

_pragma(classify_level=basic, topic={demo})
_method distance_filter_collection.equals?(other)
	_return _self.is_class_of?(other) _andif 
		other.equals_in_details?(.base_collections, .geom_name, .distance, .arg, .inverse?)
_endmethod
$

_pragma(classify_level=restricted, topic={demo})
_method distance_filter_collection.equals_in_details?(base_cols, geom_name, distance, arg, inverse?)
	_if _not _super.equals_in_details?(base_cols) _then _return _false _endif
	
	_return .geom_name = geom_name _andif
		.distance = distance _andif
		.arg.equals?(arg) _andif
		.inverse? = inverse?
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method distance_filter_collection.distance_value
	_local world << _self.world
	_local distance << .distance.value_in(world.unit)
	_return distance 
_endmethod
$

_pragma(classify_level=basic, topic={analysis, collections})
_method distance_filter_collection.includes?(rec)
	_local geom << rec.geometry(.geom_name)
	_if geom _is _unset
	_then
		_return _false
	_endif
	_local distance << _self.distance_value
	_if _not .inverse?
	_then
		# if geon is near to any of them, then it is true.
		_for i_geom _over .arg.fast_geometries()
		_loop
			_if geom.distance_to_within?(i_geom, distance)
			_then
				_return _true
			_endif
		_endloop
		_return _false
	_else
		# geom should not be near to any of them. So none should be
		# within the the distance.
		_for i_geom _over .arg.fast_geometries()
		_loop
			_if geom.distance_to_within?(i_geom, distance)
			_then
				_return _false 
			_endif
		_endloop
		_return _true 
	_endif 
_endmethod
$

_pragma(classify_level=basic, topic={analysis, collections})
_iter _method distance_filter_collection.fast_elements()
	_local distance << _self.distance_value
	_for i_geom _over _self.base_collection.fast_geometries(_unset, .geom_name)
	_loop
		_local geom_coord << i_geom.bounds.centre
		_local bounds << bounding_box.new_centred(geom_coord.x, geom_coord.y, distance)

		_if _not .inverse?
		_then
			# If i_geom is near to any of them, then it should be yielded.
			_for i_arg_geom _over .arg.fast_geometries(bounds)
			_loop
				_if i_geom.distance_to_within?(i_arg_geom, distance)
				_then 
					_local rwo << i_geom.rwo
					_if rwo _isnt _unset
					_then 
						_loopbody(rwo)
						_leave 
					_endif 
				_endif
			_endloop
		_else
			# i_geom shoul not be near to any of the .args elements, only
			# then it is included.
			_for i_arg_geom _over .arg.fast_geometries(bounds)
			_loop
				_if i_geom.distance_to_within?(i_arg_geom, distance)
				_then
					_leave
				_endif
			_finally
				_local rwo << i_geom.rwo
				_if rwo _isnt _unset
				_then 
					_loopbody(rwo)
				_endif
			_endloop
		_endif 
	_endloop
_endmethod
$

_pragma(classify_level=basic, topic={analysis, collections})
_method distance_filter_collection.convert_to_geometry(_optional bounds)
	_local gs << geometry_set.new()
	_local distance << _self.distance_value
	
	_for i_geom _over _self.base_collection.fast_geometries(bounds, .geom_name)
	_loop
		_local geom_coord << i_geom.bounds.centre
		_local scan_bounds << bounding_box.new_centred(geom_coord.x, geom_coord.y, distance)

		_if _not .inverse?
		_then
			# if i_geom is near to any of the .args then add it to gs
			_for i_arg_geom _over .arg.fast_geometries(scan_bounds)
			_loop
				_if i_geom.distance_to_within?(i_arg_geom, distance)
				_then
					gs.add(i_geom)
					_leave 
				_endif
			_endloop
		_else
			# if i_geom is near to any of the .args then it should not be
			# added to gs
			_for i_arg_geom _over .arg.fast_geometries(scan_bounds)
			_loop
				_if i_geom.distance_to_within?(i_arg_geom, distance)
				_then
					_leave
				_endif
			_finally 
				gs.add(i_geom)
			_endloop
		_endif 
	_endloop
	_return gs
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method distance_filter_collection.description
	_local sw_col << _self.expose()
	_local fd << sw_col.field(.geom_name)
	
	_local format << unit_specific_format.new_with_properties(.distance.unit,
								  :float_decimal_places,0)
	_local distance_string << format.format(.distance)
	_if .inverse?
	_then 
		_return _self.message(:description_inverse, sw_col.external_name, fd.external_name, distance_string)
	_else
		_return _self.message(:description, sw_col.external_name, fd.external_name, distance_string)
	_endif 
_endmethod
$
