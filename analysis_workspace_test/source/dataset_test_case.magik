#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:dataset_test_case)
$

_pragma(classify_level=basic, topic={analysis})
##
## Test using geometry filters.
def_slotted_exemplar(:dataset_test_case,
	{
		{:ds, _unset},
		{:file_name, _unset}
	},
	:base_analysis_test_case)
$



_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.set_up()
	_local source_path << smallworld_product.get_resource_file(
				      "analysis.ds",
				      "data",
				      rwan:analysis_dataset_manager.module_name)
	_local target_path << system.temp_file_name("munit_analysis.ds")
	system.file_copy(source_path, target_path)
	.file_name << target_path
	.ds << rwan:analysis_dataset_manager.open(:test, .file_name)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.tear_down()
	.ds.discard()
	system.unlink( .file_name, _true, _true)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_sw_col()
	_local rcol << rwan:sw_collection.new(.ds, _self.min_road_collection)
	_return _self.basic_storage_test(rcol)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_geometry_col()
	_local area << _self.area_surrounding_parkers_piece(.ds)
	_local gs << geometry_set.new_with(area)
	_local gcol << rwan:geometry_collection.new(.ds, gs)
	_self.basic_storage_test(gcol)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_area_col()
	_local area << _self.area_surrounding_parkers_piece(.ds)
	_local area_col << rwan:geometry_collection.new(.ds, geometry_set.new_with(area))
	_self.basic_storage_test(area_col)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_filter_by_geometry_col()
	_local hcol << rwan:sw_collection.new(.ds, _self.hotel_collection)
	_local area << _self.area_surrounding_parkers_piece(.ds)
	_local area_col << rwan:geometry_collection.new(.ds, geometry_set.new_with(area))
	_local hcol1 << hcol.filter_by_geometry(:location, :within, area_col, :geometry)
	
	_return _self.basic_storage_test(hcol1)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_filter_by_distance_col()
	_local hcol << rwan:sw_collection.new(.ds, _self.hotel_collection)
	_local area << _self.area_surrounding_parkers_piece(.ds)
	_local area_col << rwan:geometry_collection.new(.ds, geometry_set.new_with(area))
	_local hcol1 << hcol.filter_by_distance(:location, length_value(10,:m), _false, area_col, :geometry)
	
	_return _self.basic_storage_test(hcol1)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_filter_by_predicate_col()
	_local col << _self.min_road_collection
	_local rcol << rwan:sw_collection.new(.ds, col)
	_local rcol1 << rcol.filter_by_predicate(predicate.eq(:road_type, "A-Road"))
	_self.basic_storage_test(rcol1)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_follow_root_col()
	_local pcol << rwan:sw_collection.new(.ds, _self.pub_rest_collection)
	_local acol << pcol.follow_join(:min_roads)
	_local pcol1 << acol.follow_root(pcol)
	
	_self.basic_storage_test(pcol1)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_follow_method_col()
	_local road_col << rwan:sw_collection.new(.ds, _self.min_road_collection)
	_local m_col << road_col.follow_method(:hotel_10)
	
	_self.basic_storage_test(m_col)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_follow_topology_col()
	_local pcol << rwan:sw_collection.new(.ds, _self.pub_rest_collection)
	_local acol << pcol.follow_topology(:location, _self.min_road_collection)
	_self.basic_storage_test(acol)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_follow_trace_col()
	_local pcol << rwan:sw_collection.new(.ds, _self.pub_rest_collection)
	_local acol << pcol.follow_trace(:location, _self.min_road_collection, property_list.new(), length_value(10,:m))
	_self.basic_storage_test(acol)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_follow_join_col()
	_local pcol << rwan:sw_collection.new(.ds, _self.pub_rest_collection)
	_local acol << pcol.follow_join(:min_roads)
	_self.basic_storage_test(acol)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_binary_op_geometry_col()
	_local acol1 << _self.area_collection(.ds, {0,0,100000,0,100000,100000,0,100000,0,0})
	_local acol2 << _self.area_collection(.ds, {50000,50000,200000,50000,200000,200000,50000,200000,50000,50000})

	_local bin_col << acol1.binary_op_geometry(:geometry, :union, acol2, :geometry)
	_self.basic_storage_test(bin_col)

	_local park_col << rwan:sw_collection.new(.ds, _self.park_collection)
	bin_col << acol1.binary_op_geometry(:geometry, :union, park_col, :coverage)
	_self.basic_storage_test(bin_col)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_buffer()
	_local hotel_col << rwan:sw_collection.new(.ds, _self.hotel_collection)
	_local subt << hotel_col.buffer(:location, length_value.new(12,:m), :square, :truncate)
	
	_self.basic_storage_test(subt)	
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.test_materialized_col()
	_local hotel_col << rwan:sw_collection.new(.ds, _self.hotel_collection)
	
	_local settings << materialization_settings.new(_self.hotel_collection)
	_for i_field _over hotel_col.expose().physical_fields()
	_loop
		_if settings.field_allowed?(i_field.name)
		_then 
			settings.add_field(i_field.name)
		_endif 
	_endloop 
	_local mat_col << rwan:materialized_collection.new(.ds,
							   hotel_col,
							   settings)
	
	_self.basic_storage_test(mat_col)
_endmethod
$


_pragma(classify_level=basic, topic={analysis})
_method dataset_test_case.basic_storage_test(col)
	## 
	##
	_local ws << workspace.new()
	_local holder << collection_holder.new(col, :name, _unset, _unset)
	ws.add_holder(holder)
	
	.ds.store(ws)
	_local ws_back << .ds.retrieve()
	_local holders_back << ws_back.holders
	_self.assert_is(1, holders_back.size, "One stored and one retrieved")
	_local col_back << holders_back.an_element().collection
	
	_self.assert_true(col_back.is_class_of?(col), "Classes should match")
	_self.assert_true(col.equals?(col_back), "what goes in, should come out")
	
	_return col_back
_endmethod
$
