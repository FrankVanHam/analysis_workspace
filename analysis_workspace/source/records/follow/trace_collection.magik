#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:trace_collection)

_pragma(classify_level=basic, topic={analysis})
##
## Analysis collection that will trace the topology of a
## geometry of the base collection to another collection. Stop
## predicates can apply, even a maximum length.
##
def_slotted_exemplar(:trace_collection,
	{
		{:source_geom_name,  _unset},
		{:stop_predicates,   _unset},
		{:max_length,        _unset},
		
		{:actual_ds_name,    _unset},
		{:actual_table_name, _unset}
	}, :base_follow_collection)
$


_pragma(classify_level=basic, topic={analysis})
_method trace_collection.new(dsm, source_col, source_geom_name, actual_col, stop_preds, max_length)
	_return _clone.init(dsm, source_col, source_geom_name, actual_col, stop_preds, max_length)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_collection.init(dsm, source_col, source_geom_name, actual_col, stop_preds, max_length)

	_if stop_preds _is _unset _then condition.raise(:error) _endif
	_if max_length _is _unset _then condition.raise(:error) _endif 
	
	.source_geom_name << source_geom_name
	_if actual_col _isnt _unset
	_then 
		.actual_ds_name << actual_col.dataset.original_dataset_name
		.actual_table_name << actual_col.name
	_endif
	# protect agains nonsense
	source_col.assert_geom_name(.source_geom_name)

	_self.assert_stop_predicates(stop_preds)
	.stop_predicates << stop_preds
	.max_length      << max_length
	_return _super.init(dsm, source_col)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_collection.assert_stop_predicates(stop_preds)
	_for i_key, i_vec _over stop_preds.fast_keys_and_elements()
	_loop
		_if i_vec.is_class_of?({}).not _then condition.raise(:error, :string, "value needs to be a vector") _endif
		_for i_elem _over i_vec.fast_elements()
		_loop
			_if _not(i_elem _is _unset _orif 
				 i_elem.is_kind_of?(predicate))
			_then
				condition.raise(:error, :string, "value needs to be unset or predicate")
			_endif 
		_endloop 
	_endloop 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method trace_collection.activate_editor_in(dialog, holder)
	_return dialog.edit_follow_trace_dialog(holder,
						.source_collection,
						.source_geom_name, _self.expose(),
						.stop_predicates, .max_length)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_collection.serial_slots()
	_local (keys, values) << _super.serial_slots()
	keys.add_all_last({:geom_name, :actual_ds_name, :actual_table_name, :stop_preds, :max_length})
	values.add_all_last({.source_geom_name, .actual_ds_name, .actual_table_name, _self.stop_predicates_eval_string, .max_length})
	_return keys, values	
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_collection.init_from_serial(dsm, source_col,
					  source_geom_name, actual_ds_name, actual_table_name,
					  stop_preds_string, max_length)
    _super.init_from_serial(dsm, source_col)
    .source_geom_name << source_geom_name
    .actual_ds_name << actual_ds_name
    .actual_table_name << actual_table_name
    .stop_predicates  << stop_preds_string.evaluate()
    .max_length       << max_length
    _return _self 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_collection.stop_predicates_eval_string
	_local s << internal_text_output_stream.new()
	.stop_predicates.store_on(s)
	_return s.string
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method trace_collection.equals?(other)
	_return _self.is_class_of?(other) _andif
		other.equals_in_details?(.source_collection, .source_geom_name,
					 .actual_ds_name, .actual_table_name,
					 .stop_predicates, .max_length)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_collection.equals_in_details?(source_col, source_geom_name,
					    actual_ds_name, actual_table_name,
					    stop_preds, max_length)
	_return _super.equals_in_details?(source_col) _andif 
		.source_geom_name = source_geom_name _andif
		.actual_ds_name = actual_ds_name _andif
		.actual_table_name = actual_table_name _andif
		.max_length = max_length _andif
		_self.predicates_equal?(.stop_predicates, stop_preds)
_endmethod
$

###################################################################################################################

_pragma(classify_level=basic, topic={analysis})
_method trace_collection.editable?
	_return _true
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_collection.predicates_equal?(preds1, preds2)
	_if preds1.size <> preds2.size _then _return _false _endif
	_for i_key, i_elem _over preds1.fast_keys_and_elements()
	_loop
		_local elem2 << preds2[i_key]
		_if i_elem <> elem2 _then _return _false _endif
	_endloop
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_collection.read_stream(_optional filter)
	## Return my read_stream. If filter is set, the let the filter
	## filter my results. 
	#
	_local str << rwan:trace_read_stream.new(.source_collection, .source_geom_name,
						 .stop_predicates, _self.world_length, 
						 _self.expose())
	_if filter _isnt _unset
	_then
		_return filter.filter_stream(str)
	_else 
		_return str
	_endif 
_endmethod
$

#_pragma(classify_level=basic, topic={analysis})
#_iter _method trace_collection.fast_elements()
#	_local done << large_record_register.new(100)
#	_for i_rec _over _self.base_collection.fast_elements()
#	_loop
#		_for i_rwo _over _self.process_trace(i_rec, done)
#		_loop
#			_loopbody(i_rwo)
#		_endloop
#	_endloop
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={analysis})
#_private _iter _method trace_collection.process_trace(rec, done)
#	_dynamic !root_query!
#	_local geom << rec.geometry(.source_geom_name)
#	_if geom _is _unset _then _return _endif 
#	
#	rwo_type << _self.base_collection.expose().name
#	_for i_con _over _self.trace(geom)
#	_loop
#		_if _not done.includes?(i_con)
#		_then
#			_if !root_query! _isnt _unset
#			_then
#				!root_query![rwo_type] << rec
#			_endif 
#			_loopbody(i_con)
#			done.add(i_con)
#		_endif 
#	_endloop
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={analysis})
#_private _method trace_collection.trace_stop_predicates
#	_if .stop_predicates _is _unset
#	_then
#		_return _unset
#	_else
#		_local preds << property_list.new()
#		_for i_name, i_pred _over .stop_predicates.fast_keys_and_elements()
#		_loop
#			preds[i_name] << {i_pred}
#		_endloop 
#		_return preds
#	_endif 
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={analysis})
#_private _iter _method trace_collection.trace(geom)
#	_local nf << network_follower.new(50)
#	_for i_node _over geom.all_nodes()
#	_loop
#		nf.trace_out(i_node, :stop_predicates, _self.trace_stop_predicates, :max_cost, _self.max_length_value)
#		_local travelled << nf.visited_rwos
#		_for i_rec _over travelled.fast_elements()
#		_loop
#			_if i_rec.rwo_type _is .actual_table_name
#			_then
#				_loopbody(i_rec)
#			_endif
#		_endloop
#	_endloop 
#_endmethod
#$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_collection.world_length
	_local world << .source_collection.expose().record_exemplar.rwan_world_for(.source_geom_name)
	_local length << .max_length.value_in(world.unit)
	_return length
_endmethod
$

#
#_pragma(classify_level=basic, topic={analysis})
#_method trace_collection.description(translator)
#	_local base_name   << translator.name_for_collection(_self.base_collection)
#	_local actual_name << _self.actual_collection.external_name
#	_local geom_name << _self.base_collection.expose().field(.source_geom_name).external_name
#	
#	_return _self.message(:description, actual_name, geom_name, base_name)
#_endmethod
#$
#

_pragma(classify_level=advanced, topic={analysis})
_method trace_collection.display_tree_in(owner)
	_return owner.display_tree_for_trace_collection(_self, .source_collection,
							_self.expose(), .source_geom_name)
_endmethod
$
