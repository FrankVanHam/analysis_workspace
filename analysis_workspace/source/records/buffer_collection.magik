#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:buffer_collection)

_pragma(classify_level=basic, topic={analysis})
##
## A collection that represents a buffer around some other
## collection. In its nature self is an area, can be big and
## complex, but still an area.
def_slotted_exemplar(:buffer_collection,
	{
		{:source_collection, _unset},
		{:source_geom_name,  _unset},
		{:distance, _unset},
		{:corner_style, _unset},
		{:end_style,_unset},
		{:world_distance, _unset}
	}, :base_record_collection)
$

message_handler.new(:buffer_collection).add_use(:base_record_collection)
$

_pragma(classify_level=basic, topic={analysis})
_method buffer_collection.new(dsm, source_col, source_geom_name, distance, corner_style, end_style)
	_return _clone.init(dsm, source_col, source_geom_name, distance, corner_style, end_style)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method buffer_collection.init(dsm, source_col, source_geom_name, distance, corner_style, end_style)
	.source_collection << source_col
	.source_geom_name << source_geom_name
	.source_collection.assert_geom_name(.source_geom_name)
	
	.distance << distance
	.corner_style << corner_style
	.end_style << end_style
	
	_self.set_world_distance()
	_return _super.init(dsm)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method buffer_collection.activate_editor_in(dialog, holder)
	_return dialog.edit_buffer_dialog(holder,
					  .source_collection,
					  .source_geom_name,
					  .distance, .corner_style, .end_style)
_endmethod
$


_pragma(classify_level=restricted, topic={analysis})
_method buffer_collection.init_from_serial(dsm, _gather p_args)
    _super.init_from_serial(dsm, _scatter p_args)
    _self.set_world_distance()
    _return _self 
_endmethod
$

###################################################################################################################


_pragma(classify_level=restricted, topic={analysis})
_method buffer_collection.editable?
	_return _true
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method buffer_collection.geometry_refs
	>> {(geom_ref.new(:area,
			  _self.message(:area),
			  :area,
			  _false))}
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method buffer_collection.expose()
	_return .source_collection.expose()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method buffer_collection.geometry_for(rec, geom_name)
	_local source_geom << .source_collection.geometry_for(rec, .source_geom_name)
	_if source_geom _isnt _unset
	_then 
		_local area << source_geom.buffer(.world_distance, .corner_style, .end_style)
		_return pseudo_area.new_for_world(area, source_geom.world)
	_else
		_return _unset 
	_endif 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method buffer_collection.ref_collections
	## return the collections I depend on
	_return {.source_collection}
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method buffer_collection.size
	_return .source_collection.size
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method buffer_collection.set_world_distance()
	_local sw_col << .source_collection.expose()
	_local world << _if sw_col _isnt _unset
			_then >> sw_col.record_exemplar.rwan_world_for(.source_geom_name)
			_else >> .source_collection.an_element().world
			_endif 
	.world_distance << .distance.value_in(world.unit)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method buffer_collection.read_stream(_optional filter)
	## Return my read_stream. If filter is set, the let the filter
	## filter my results. Otherwise set myself as the filter of my
	## source_collection
	#
	_local str << .source_collection.read_stream()
	_if filter _isnt _unset
	_then
		_return filter.filter_stream(str)
	_else 
		_return str
	_endif 
_endmethod
$

#
#_pragma(classify_level=basic, topic={analysis})
#_method buffer_collection.area
#	## Return the area by converting the base collection to a
#	## geometry(set) and do the buffer() operation. Could return
#	## unset in case of degenerate area.
#	_return _self.convert_to_geometry()
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method buffer_collection.convert_to_geometry()
#	_handling geometry_analysis_skip_invalid _with _proc(c) c.report_contents_on(!output!) _endproc
#	
#	_local gs << _self.base_collection.convert_to_geometry(.geom_name)
#	_local world << _self.world
#	_local distance << _self.distance_value
#	_local gs_result << gs.buffer(distance, .corner_style, .end_style)
#	_if gs_result _isnt _unset
#	_then
#		gs_result.world << world
#	_endif 
#	_return gs_result
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_iter _method buffer_collection.fast_geometries()
#	_local area << _self.convert_to_geometry()
#	_loopbody(area) 
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method buffer_collection.goto_bounds
#	_local gs << _self.base_collection.convert_to_geometry(.geom_name)
#	_local bounds << gs.bounds
#	_local distance << _self.distance_value
#	_local goto_bounds << bounds.sectors.buffer(distance, .corner_style).bounds
#	_return goto_bounds
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method buffer_collection.description(translator)
#	_local base_name << translator.name_for_collection(_self.base_collection)
#	_local format << unit_specific_format.new_with_properties(.distance.unit,
#								  :float_decimal_places,0)
#	_local distance_string << format.format(.distance)
#	_return _self.message(:description, base_name, distance_string)
#_endmethod
#$

_pragma(classify_level=advanced, topic={analysis})
_method buffer_collection.display_tree_in(owner)
	_return owner.display_tree_for_buffer_collection(_self, .source_collection, .source_geom_name, .distance)
_endmethod
$
