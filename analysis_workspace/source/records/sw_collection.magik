#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:sw_collection)
$

_pragma(classify_level=basic, topic={analysis})
##
## A collection that is based on a actual smallworld collection.
def_slotted_exemplar(:sw_collection,
	{
		{:actual_ds_name,        _unset},
		{:actual_table_name, _unset}
	}, :base_record_collection)
$


_pragma(classify_level=basic, topic={analysis})
_method sw_collection.new(dsm, actual_col)
	_return _clone.init(dsm, actual_col)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method sw_collection.init(dsm, actual_col)
	.actual_table_name << actual_col.name
	.actual_ds_name << actual_col.dataset.original_dataset_name
	_return _super.init(dsm)
_endmethod
$
#
#_pragma(classify_level=basic, topic={analysis})
#_method sw_collection.origin_is_sw_collection?
#	_return _true 
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method sw_collection.is_sw_collection?
#	_return _true 
#_endmethod
#$
#
_pragma(classify_level=basic, topic={analysis})
_method sw_collection.is_record_collection?
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method sw_collection.serial_slots()
	_local (keys, values) << _super.serial_slots()
	keys.add_all_last({:actual_ds_name, :actual_table_name})
	values.add_all_last({.actual_ds_name, .actual_table_name})
	_return keys, values
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method sw_collection.init_from_serial(dsm, nrefs, actual_ds_name, actual_table_name)
	_super.init_from_serial(dsm, nrefs)
	.actual_ds_name << actual_ds_name
	.actual_table_name << actual_table_name
	_return _self 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.equals?(other)
	_return _self.is_class_of?(other) _andif
		other.equals_in_details?(.nrefs, .actual_ds_name, .actual_table_name)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method sw_collection.equals_in_details?(nrefs, actual_ds_name, actual_table_name)
	_return _super.equals_in_details?(nrefs) _andif
		.actual_ds_name = actual_ds_name _andif
		.actual_table_name = actual_table_name
_endmethod
$

###############################################################################

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.actual_collection
	_return gis_program_manager.databases[.actual_ds_name].collections[.actual_table_name]
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.expose()
	## Expose the internal smallworld collection
	_return _self.actual_collection
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.geometry_set(geom_name)
	## Return a geometry set for the geometry geom_name.
	_local sw_col << _self.actual_collection
	_local world  << sw_col.record_exemplar.rwan_world_for(geom_name)
	_return sw_col.geometry_set(world, _unset, geom_name)
_endmethod
$

#
#_pragma(classify_level=basic, topic={analysis})
#_method sw_collection.has_geometry?
#	_return _self.actual_collection.descriptor.has_geometry_fields?
#_endmethod
#$
#
_pragma(classify_level=basic, topic={analysis})
_method sw_collection.geometry_refs
	_local refs << rope.new()
	_for i_fd _over _self.actual_collection.descriptor.geometry_fields()
	_loop
		_if i_fd.name _is :meatball _then _continue _endif 
		refs.add(geom_ref.new(i_fd.name,
				      i_fd.external_name,
				      i_fd.geom_category,
				      i_fd.has_topology?))
	_endloop
	_return refs
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.size_is_fast?
	_return _self.actual_collection.size_is_fast?
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.size
	_return _self.actual_collection.size
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.read_stream(_optional filter)
	## Provide a stream on the content of self.
	_if filter _isnt _unset
	_then
		_return filter.filter_stream_for_actual_collection(_self.actual_collection)
	_else 
		_return _self.actual_collection.read_stream()
	_endif 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method sw_collection.goto_bounds
	_if _self.actual_collection.descriptor.has_geometry_fields?.not
	_then
		_return _unset
	_endif 
	_local bounds << _unset
	_for i_rec _over _self.fast_elements()
	_loop
		_try 
			sub_bounds << i_rec.goto_bounds
		_when error
		_endtry
		_if sub_bounds _isnt _unset
		_then 
			bounds << sub_bounds.union(bounds)
		_endif 
	_endloop
	_return bounds
_endmethod
$


#
#_pragma(classify_level=basic, topic={analysis})
#_method sw_collection.description(translator)
#	_return _self.actual_collection.external_name
#_endmethod
#$

_pragma(classify_level=advanced, topic={analysis})
_method sw_collection.display_tree_in(owner)
	_return owner.display_tree_for_sw_collection(_self, _self.actual_collection)
_endmethod
$
