#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:workspace)
$

_pragma(classify_level=restricted, topic={roos,analysis})
##
## A workspace, an ordered list of holds for
## analysis_collections. 
##
def_slotted_exemplar(:workspace,
	{
		{:dirty?, _unset, :readable},
		{:top_holders, _unset, :readable},
		{:holders, _unset, :readable},
		{:dsm, _unset, :readable},
		{:create_date, _unset},
		{:create_user, _unset}
	})
$

serial_structure_mixin.add_child(workspace)
$

workspace.define_shared_constant(:serial_structure, :slotted, :public)
$

_pragma(classify_level=restricted, topic={roos,analysis})
_method workspace.new()
	_return _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={roos,analysis})
_private _method workspace.init()
	.dirty? << _false 
	.top_holders << rope.new()
	.holders << rope.new()
	.create_date << date_time_now()
	_try 
		.create_user << system.user_name
	_when error
		.create_user << "Unknow"
	_endtry 
	_return _self 	 
_endmethod
$

_pragma(classify_level=restricted, topic={roos,analysis})
_method workspace.open?
	>> .dsm _isnt _unset
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.serial_slots()
    _local keys   << rope.new_with(:top_holder_indexes, :holders, :create_date, :create_user)
    _local values << rope.new_with(_self.top_holder_indexes, .holders, .create_date, .create_user)
    _return keys, values
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.new_from_serial(keys,values)
    _return _clone.init_from_serial(_scatter values)
_endmethod
$


_pragma(classify_level=basic, topic={analysis})
_private _method workspace.init_from_serial(top_holder_indexes, holders,
					    create_date, create_user)
	.dirty? << _false
	.top_holders << _self.top_holders_from_index(holders, top_holder_indexes)
	.holders << holders
	.create_date << create_date
	.create_user << create_user
	_return _self 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_private _method workspace.top_holder_indexes
	_local holders << .holders
	_return .top_holders.map(_proc(h)
					 _import holders
					 >> holders.index_of(h)
				 _endproc)
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_private _method workspace.top_holders_from_index(holders, indexes)
	_local top_holders << rope.new_for(indexes.size)
	_for i_idx _over indexes.fast_elements()
	_loop
		top_holders.add(holders[i_idx])
	_endloop 
	_return top_holders
_endmethod
$



_pragma(classify_level=basic, topic={analysis})
_method workspace.holder_for(col)
	_for i_holder _over .holders.fast_elements()
	_loop
		_if i_holder.collection _is col
		_then
			_return i_holder
		_endif
	_endloop 
_endmethod
$

_method workspace.name_for_collection(col)
	_return _self.holder_for(col).name
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.top_holders(selection)
	_local cp << rope.new()
	_for i_holder _over .top_holders.fast_elements()
	_loop
		_if selection.includes?(i_holder)
		_then
			cp.add(i_holder)
		_endif 
	_endloop
	_return cp
_endmethod
$

#########################################################

_pragma(classify_level=basic, topic={analysis})
_method workspace.add_holder(holder)
	.holders.add(holder)
	.top_holders.add_last(holder)
	_self.remove_refs(holder)
	.dirty? << _true  
_endmethod
$


_pragma(classify_level=basic, topic={analysis})
_method workspace.add_holders(holders)
	
	.holders.add_all_last(holders)
	.top_holders.add_all_last(holders)
	_for i_holder _over holders.fast_elements()
	_loop
		_self.remove_refs(i_holder)
	_endloop 
	.dirty? << _true 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.remove_holder(holder)
	.holders.remove(holder)
	.top_holders.remove(holder)
	_self.add_refs(holder)
	.dirty? << _true 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.update_holder(old_holder, new_holder)
	.holders.remove(old_holder)
	.holders.add(new_holder)
	
	_local idx << .top_holders.index_of(old_holder)
	.top_holders[idx] << new_holder
	
	_self.add_refs(old_holder)
	_self.remove_refs(new_holder)
	.dirty? << _true 
_endmethod
$

#########################################################

_pragma(classify_level=basic, topic={analysis})
_private _method workspace.remove_refs(holder)
	_for i_ref _over holder.ref_collections.fast_elements()
	_loop
		_local ref_holder << _self.holder_for(i_ref)
		.top_holders.remove(ref_holder)
	_endloop 	
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_private _method workspace.add_refs(holder)
	_for i_ref _over holder.ref_collections.fast_elements()
	_loop
		_local ref_holder << _self.holder_for(i_ref)
		.top_holders.add(ref_holder)
	_endloop 	
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.move_up(holder)
	_local index << .top_holders.index_of(holder)
	_if index <> 1
	_then
		.top_holders.remove_nth(index)
		.top_holders.add_nth(holder, index-1)
		
		.dirty? << _true 
	_endif 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.can_move_up?(holder)
	_return .top_holders.index_of(holder) <> 1
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.move_down(holder)
	_local index << .top_holders.index_of(holder)
	_if index <> .top_holders.size
	_then
		.top_holders.remove_nth(index)
		.top_holders.add_nth(holder, index+1)
		
		.dirty? << _true 
	_endif 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.can_move_down?(holder)
	_return .top_holders.index_of(holder) <> .top_holders.size 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.all_holders
	_return .holders
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.set_dirty()
	.dirty? << _true 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.set_clean()
	.dirty? << _false 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.empty?
	_return .holders.empty?
_endmethod
$

_pragma(classify_level=restricted, topic={roos,analysis})
_method workspace.set_dataset_manager(dsm)
	.dsm << dsm
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method workspace.save()
	.dsm.store(_self)
	_self.set_clean()	
_endmethod
$
