#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:base_collection)
$

_pragma(classify_level=basic, topic={analysis})
##
## Base class for all analysis collections defining the abstract
## interface that must be implemented by all subclasses.
##
## Note that subclasses either supply records, areas or
## geometry in general.
##
def_slotted_exemplar(:base_collection,
	{
		{:dsm,    _unset}
	})
$

_pragma(classify_level=basic, topic={analysis})
# Support for XML serialisation
serial_structure_mixin.add_child(base_collection)
$

_pragma(classify_level=basic, topic={analysis})
# Support for XML serialisation
base_collection.define_shared_constant(:serial_structure, :slotted, :public)
$

_pragma(classify_level=restricted, topic={analysis})
_private _method base_collection.init(dsm)
	.dsm << dsm
	_return _self 
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method base_collection.init_copy()
	_return _self
_endmethod
$


#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.base_collections
#	_return .base_collections
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.base_collection
#	_return .base_collections.an_element()
#_endmethod
#$
#

_pragma(classify_level=basic, topic={analysis})
_method base_collection.is_record_collection?
	## is this a collection of records?
	_return _false
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.editable?
	_return _false 
_endmethod
$

#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.viewable?
#	_return _self.editable? 
#_endmethod
#$
#
_pragma(classify_level=basic, topic={analysis})
_method base_collection.has_geometry?
	# has self a geometry field or geometry?
	_return _true 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.geometry_refs
	## Expose the base geometry fields that can be used on self
	>> {}	
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.expose()
	## Expose the base smallworld collection. Could be unset 
	## 
	_return _unset
_endmethod
$

_pragma(classify_level=basic, topic={demo})
_iter _method base_collection.fast_elements()
	_local str << _self.read_stream()
	_protect
		_loop 
			_local value << str.get()
			_if value _is _unset _then _leave _endif
			_loopbody(value)
		_endloop
	_protection
		str.close()
	_endprotect 
_endmethod
$

_pragma(classify_level=basic, topic={demo})
_method base_collection.an_element()
	_local str << _self.read_stream()
	_protect
		_return str.get()
	_protection
		str.close()
	_endprotect 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.size
	_if _self.size_is_fast?
	_then
		condition.raise(:error, :string, write("If size is fast, then dont use this slow-ass method"))
	_endif
	_local c << 0
	_for i_rec _over _self.fast_elements()
	_loop
		c +<< 1
	_endloop
	_return c
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.assert_geom_name(name)
	## make sure that name is a valid geometry name for me.
	_if rope.new_from(_self.geometry_refs).select(predicate.eq(:name, name)).empty?
	_then
		condition.raise(:error, :string, write_string( "The geometry named ", name, " is not available for ", _self))
	_endif 
_endmethod
$


_pragma(classify_level=basic, topic={analysis})
_abstract _method base_collection.activate_editor_in(plugin)
	## Callback method from the plugin to let the collection
	## determine what editor to use.	
_endmethod
$

#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.origin_is_sw_collection?
#	_if _self.base_collection _isnt _unset 
#	_then
#		_return _self.base_collection.origin_is_sw_collection?
#	_else
#		_return _false
#	_endif 
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.is_sw_collection?
#	_return _false 
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.is_spatial?
#	_return _false 
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.is_area?
#	_return _false 
#_endmethod
#$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.serial_slots()
    _local keys   << rope.new_with(:oop)
    _local values << rope.new_with(_self.as_oop)
    _return keys, values
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.new_from_serial(keys,values)
	_dynamic !current_analysis_dataset_manager!
	
	_local dsm << !current_analysis_dataset_manager!
	_local oop << values[1]
	_local col << dsm.collection_at_oop(oop)
	_if col _is _unset
	_then 
		col << _clone.init_from_serial(dsm,_scatter values.slice_to_end(2))
		dsm.cache_collection_at_oop(oop, col)
	_endif 
	_return col
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_private _method base_collection.init_from_serial(dsm)
	.dsm << dsm
	_return _self 
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.equals?(other)
	_if _not _self.is_class_of?(other) _then _return _false _endif
	_return _self.equals_in_details?()
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.equals_in_details?()
	_return _true
_endmethod
$

#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.is_leaf?
#	_return .base_collections.empty?
#_endmethod
#$
#
#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.world
#	_return _self.base_collection.world
#_endmethod
#$
#
#_pragma(classify_level=basic, topic={analysis})
#_iter _method base_collection.branch_to_root()
#	_loopbody(_self)
#	_if _self.base_collection _isnt _unset 
#	_then
#		_for i_col _over _self.base_collection.branch_to_root()
#		_loop
#			_loopbody(i_col)
#		_endloop
#	_endif 
#_endmethod
#$
#

_pragma(classify_level=basic, topic={analysis})
_method base_collection.goto_bounds
	## Provide the bounds of the collection
	show(_self)
	condition.raise(:error, :string, "Subclass should implement")
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.geometry_set(geom_name)
	## Return a geometry set for the geometry geom_name.
	show(_self)
	condition.raise(:error, :string, "Subclass should implement")
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.ref_collections
	## return the collections I depend on
	_return {}
_endmethod
$

_pragma(classify_level=basic, topic={analysis})
_method base_collection.geometry_refs_for(actual_collection)
	_local refs << rope.new()
	_for i_fd _over actual_collection.descriptor.geometry_fields()
	_loop
		_if i_fd.name _is :meatball _then _continue _endif 
		refs.add(geom_ref.new(i_fd.name,
				      i_fd.external_name,
				      i_fd.geom_category,
				      i_fd.has_topology?))
	_endloop
	_return refs
_endmethod
$


_pragma(classify_level=basic, topic={analysis})
_method base_collection.size_is_fast?
	_return _false 
_endmethod
$


#
#_pragma(classify_level=basic, topic={analysis})
#_method base_collection.convert_to_geometry_is_fast?
#	_return _false 
#_endmethod
#$
#

#
#_pragma(classify_level=basic, topic={analysis})
#_iter _method base_collection.fast_geometries(geom_name)
#	_for i_rec _over _self.fast_elements()
#	_loop
#		_local geom << i_rec.geometry(geom_name)
#		_if geom _isnt _unset
#		_then
#			_loopbody(geom)
#		_endif 
#	_endloop 
#_endmethod
#$
#

_pragma(classify_level=basic, topic={analysis})
_method base_collection.discard()
	.dsm << _unset
#	_if .source_collection _isnt _unset
#	_then
#		.source_collection.discard()
#	_endif 
_endmethod
$

#_pragma(classify_level=advanced, topic={analysis})
#_method base_collection.description(translator)
#	_return _self.class_name
#_endmethod
#$

#_pragma(classify_level=advanced, topic={analysis})
#_method base_collection.description(name_translator)
#	_return _self.description
#_endmethod
#$

_pragma(classify_level=advanced, topic={analysis})
_method base_collection.copy()
	_return _clone.init_copy()
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_method base_collection.message(id, _gather args)
	_return message_handler.new(_self.class_name).human_string(id, _unset, _scatter args)	
_endmethod
$
