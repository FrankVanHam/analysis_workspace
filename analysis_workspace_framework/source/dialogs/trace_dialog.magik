#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:trace_dialog)
$

_pragma(classify_level=basic, topic={analysis})
##
## dialog to construct a trace collection to trace topology
## of the source collection to find records of the target
## collection. The user can apply a maximum distance and set
## stop predicates.
##
def_slotted_exemplar(:trace_dialog,
	{
		{:max_length,               _unset},
		{:stop_predicates,          _unset},
		{:selected_stop_collection, _unset},
		{:target_collection,        _unset}
	},
	:base_dialog)
$

message_handler.new(:trace_dialog).add_uses(:model, :base_dialog)
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.set_source_holder(workspace, source_holder)
	.workspace << workspace
	.source_holder << source_holder
	.max_length    << length_value(10,:m)
	.stop_predicates << property_list.new()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.set_holder(workspace,
				holder, source_holder, source_geom_name,
				target_col, stop_preds, max_length)
	_if max_length _is _unset _then condition.raise(:error) _endif
	_if stop_preds _is _unset _then condition.raise(:error) _endif
	.workspace << workspace
	.holder << holder
	.source_holder << source_holder
	.source_geom_name << source_geom_name
	.name << holder.name
	.max_length    << max_length
	.stop_predicates << stop_preds
	.target_collection << target_col
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.activate_in(container) 
	container.top_frame.modality << :primary_modal
	_local rc << rowcol.new(container,_unset, 1, _unset, :style, :top_level,
				:col_alignment, :fill,
				:row_alignment, :fill,
				:row_resize_values, {0,0,0,100,0,0,0})
	_self.build_top_label(rc)
	_self.build_trace_selection(rc)
	_self.build_length_item(rc)
	_self.build_stop_predicates(rc)
	_self.build_name(rc)
	panel_separator.new(rc, :col_alignment, :fill) 
	_self.build_buttons(rc) 
	_return rc
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.build_trace_selection(container) 
	_local rc << rowcol.new(container, _unset, 2, _unset, :style, :nested, :col_alignment, :fill)
	_self.build_source_selection_rc(rc)
	
	sw_label_item.new(rc, _self.message(:topology) ) 
	.items[:topology_choice] << sw_text_item.new(rc, 
						     :model, _self,
						     :editable?, _false,
						     :change_selector, :|target_changed()|,
						     :col_alignment, :fill)  
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.build_length_item(container)
	_local rc << rowcol.new(container, _unset, 2, _unset, :style, :nested, :col_alignment, :fill)
	sw_label_item.new(rc, _self.message(:max_length))
	_local a_manager << unit_value_manager.new(unit_manager.unit(:m))
	.items[:max_length] << ti << sw_managed_text_item.new(rc,  
							      :model, _self,
							      :manager, a_manager,
							      :incremental_change_selector, :|max_length_changed()|,
							      :col_alignment, :fill)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.build_stop_predicates(container)
	_local rc << rowcol.new(container, _unset, 1, _unset, :style, :nested,
				:row_alignment, :fill,
				:col_alignment, :fill)

	_local rrc << _self.new_toolbar(rc)
	rrc.col_alignment << :left
	sw_label_item.new(rrc, _self.message(:stop_predicates))
	.items[:add_predicate] << image_button_item.new_safe(rrc,_self.add_image,
							     _self,:|add_predicate()|,
							     :balloon_help_id, :add_predicate_tt,
							     :insensitive_image, _self.grey_add_image)
	.items[:edit_predicate] << image_button_item.new_safe(rrc,_self.edit_image,
							     _self,:|edit_predicate()|,
							     :balloon_help_id, :edit_predicate_tt,
							     :insensitive_image, _self.grey_edit_image)
	.items[:remove_predicate] << image_button_item.new_safe(rrc,_self.remove_image,
							     _self,:|remove_predicate()|,
							     :balloon_help_id, :remove_predicate_tt,
							     :insensitive_image, _self.grey_remove_image)
	
	.items[:list] << tree_item.new(rc,
				       :mode, :one,
				       :aspect, :stop_predicates_trees,
				       :model, _self,
				       :double_click_notifier, {:|perform_safely()|, :|edit_predicate()|},
				       :select_notifier,       {:|perform_safely()|, :|predicate_selected()|},
				       :row_alignment, :fill, :col_alignment, :fill)
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.new_toolbar(container)
	rc << toolbar.new(container, _false)
	rc.col_spacing << 0
	rc.row_spacing << 0
	rc.outer_spacing << 2
	_return rc
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.on_activation()
	_self.initialise_source_geometry_choice()
	_self.initialise_target_choice()
	_self.initialise_max_length()
	_self.initialise_name()
	_return _super.on_activation()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.initialise_target_choice()
	_if .source_geom_name _isnt _unset
	_then 
		_local geom_field << .source_holder.collection.expose().field(.source_geom_name)
		_local items << _self.topology_items(geom_field)
		.items[:topology_choice].text_items << items
		_self.set_current_target_collection(items)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.initialise_max_length()
	.items[:max_length].value << .max_length
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.add_predicate()
	_local geom_field << .source_holder.collection.expose().field(.source_geom_name)
	_local possible_collections << _self.collections_for_topology(geom_field)
	_local ed << trace_stop_dialog.new_dialog(_self, possible_collections, _unset, .parent_model.ace)
	ed.activate_relative_to(_self.message(:predicate_dialog_title), _self.top_frame)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.edit_predicate()
	_local pred << .stop_predicates[.selected_stop_collection.name][1]
	_local possible_collections << {.selected_stop_collection}
	_local ed << trace_stop_dialog.new_dialog(_self, possible_collections, pred, .parent_model.ace)
	ed.activate_relative_to(_self.message(:predicate_dialog_title), _self.top_frame)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.stop_predicates_trees
	_local ds << .source_holder.collection.expose().dataset
	_local list << rope.new()
	_for i_col_name, i_preds _over .stop_predicates.fast_keys_and_elements()
	_loop
		pred << i_preds[1]
		col << ds.collection(i_col_name)
		list.add(_self.display_tree_for(pred, col))
	_endloop
	_return list
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.display_tree_for(pred, col)
	#
	_local t << display_tree.new(col)
	_local image << col.record_exemplar.legend_info_for(property_list.new())
	_if image _is _unset _orif image _is :use_default
	_then
		image << {:collection, :ui_resources}
	_endif
	_if pred _isnt _unset
	_then 
		style << {:image, image, col.external_name.copy(), _self.message(:where),
			  :blue, pred.write_string}
	_else
		style << {:image, image, col.external_name.copy()}
	_endif
	t.styled_string << style
	_return t 
_endmethod
$


_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.predicate_selected(tree_selection)
	_local tree << tree_selection.an_element()
	_if tree _isnt _unset
	_then
		col << tree.key
	_else
		col << _unset
	_endif 
	.selected_stop_collection << col
	_self.manage_actions()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.update_predicate(pred, col)
	.stop_predicates[col.name] << {pred}
	_self.refresh_list()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.remove_predicate()
	.stop_predicates.remove_key(.selected_stop_collection.name)
	_self.refresh_list()
	_self.manage_actions()	
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.refresh_list()
	_self.changed(:stop_predicates_trees, :renew)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.max_length_changed(value)
	.max_length << value
	_self.manage_actions()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.set_current_target_collection(items)
	_local value << _unset
	_if items.size > 0
	_then
		value << items[1][1]
	_endif
	_if .target_collection _isnt _unset
	_then
		_for i_vec _over items.fast_elements()
		_loop
			_if i_vec[1] _is .target_collection
			_then
				value << i_vec[1]
			_endif
		_endloop
	_endif
	.items[:topology_choice].value << value
	_self.target_changed(value)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.construct_holder()
	_local col << .source_holder.collection.follow_trace(.source_geom_name, .target_collection,
							     .stop_predicates, _self.max_length)
	_return .parent_model.new_holder(col, .name)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.max_length
	_return .items[:max_length].value	
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.target_changed(value)
	.target_collection << value
	
	_self.manage_actions()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.topology_items(geom_field) 
	_local items << rope.new()
	_local cols << _self.collections_for_topology(geom_field) 
	_for i_col _over cols.fast_elements()
	_loop
		items.add({ i_col, i_col.external_name.copy()}) 
	_endloop
	items << items.as_sorted_collection(_proc(a, b) 
						    _return a[2] _cf b[2]
					    _endproc) 
	items << rope.new_from(items) 
	_if items.empty?
	_then
		items.add({_unset, _self.message(:no_topology)})
	_endif 
	_return items
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method trace_dialog.collections_for_topology(geom_field) 
	_local sw_col << .source_holder.collection.expose()
	_local ds << sw_col.dataset
	_if geom_field.mapped?
	_then
		fds << geom_field.mapped_geometry_fields.elements
	_else
		fds << {geom_field}
	_endif
	_local done << set.new_with(sw_col.descriptor)
	_local cols << rope.new()
	_for fd _over fds.fast_elements()
	_loop
		_if _not fd.has_topology? _then _continue _endif 
		_local gs << ds.geometry_on_manifold(fd.manifold_code)
		_for i_fd _over gs.fast_elements()
		_loop
			_local dd << i_fd.owner
			_local col << dd.dataset.collections[dd.name]
			_if done.includes?(col).not
			_then 
				cols.add(col)
				done.add(col)
			_endif 
		_endloop
	_endloop 
	_return cols
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method trace_dialog.manage_actions()
	_local has_name? << .name.default("") <> ""
	_local topo? << .target_collection _isnt _unset 
	_local any? << .stop_predicates.empty?.not 
	_local sel? << .selected_stop_collection _isnt _unset

	.items[:topology_choice].enabled? << .readonly?.not
	.items[:source_geometry_choice].enabled? << .readonly?.not
	.items[:add_predicate].enabled? << .readonly?.not _andif topo?
	.items[:edit_predicate].enabled? << .readonly?.not _andif topo? _and sel?
	.items[:remove_predicate].enabled? << .readonly?.not _andif topo? _and sel?
	.items[:ok].enabled? << .readonly?.not _andif has_name? _andif topo?
	.items[:name].enabled? << .readonly?.not
	.items[:max_length].enabled? << .readonly?.not
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.edit_image
	_return smallworld_product.get_raster_image(:edit, :ui_resources)
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.grey_edit_image
	_return smallworld_product.get_raster_image(:edit_grey, :ui_resources)
_endmethod
$
_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.add_image
	_return smallworld_product.get_raster_image(:add, _self.module_name)
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.grey_add_image
	_return smallworld_product.get_raster_image(:add_grey, _self.module_name)
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.remove_image
	_return smallworld_product.get_raster_image(:remove, _self.module_name)
_endmethod
$

_pragma(classify_level=advanced, topic={analysis})
_private _method trace_dialog.grey_remove_image
	_return smallworld_product.get_raster_image(:remove_grey, _self.module_name)
_endmethod
$
