#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:spatial_filter_dialog)
$

_pragma(classify_level=restricted, topic={analysis})
##
## Dialog that constructs a spatial filter collection that does
## a spatial interaction with another collection. use this to
## find elements of collection A with a spatial relation to
## elements of collection B.
##
def_slotted_exemplar(:spatial_filter_dialog,
	{
		{:operator, _unset}
	},
	:base_dialog)
$

message_handler.new(:spatial_filter_dialog).add_uses(:model, :base_dialog)
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.set_source_holder(workspace, source_holder)
	.workspace << workspace
	.source_holder << source_holder
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.set_holder(workspace,
					 holder, source_holder, source_geom_name,
					 operator, filter_holder, filter_geom_name)
	.workspace << workspace
	.holder << holder
	.source_holder << source_holder
	.source_geom_name << source_geom_name
	.operator << operator
	.filter_holder << filter_holder
	.filter_geom_name << filter_geom_name
	.name << holder.name
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.activate_in(container)
	container.top_frame.modality << :primary_modal
	_local rc << rowcol.new(container,_unset, 1, _unset, :style, :top_level,
				:row_alignment, :fill,
				:col_alignment, :fill)
	_self.build_top_label(rc)
	_self.build_source_filter_and_operation_selection(rc)
	_self.build_explanatory_image(rc)
	_self.build_name(rc)
	panel_separator.new(rc, :col_alignment, :fill) 
	_self.build_buttons(rc)
	_return rc
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.build_source_filter_and_operation_selection(container)
	##
	_local rc << rowcol.new(container, _unset, 2, _unset, :style, :nested, :col_alignment, :fill)
	_self.build_source_selection_rc(rc)
	_self.build_filter_selection_rc(rc)
	
	sw_label_item.new(rc, _self.message(:operation))
	.items[:operation_choice] << sw_text_item.new(rc,
						      :text_items, {},
						      :editable?, _false,
						      :model, _self,
						      :change_selector, :|operation_changed()|,
						      :col_alignment, :fill)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.build_explanatory_image(container)
	.items[:explain] << sw_image_item.new(container, _self.default_image, :col_alignment, :centre)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.on_activation()
	_self.initialise_source_geometry_choice()
	_self.initialise_filter_holder_choice()
	_self.initialise_operator_choice()
	_self.initialise_name()
	_super.on_activation()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.initialise_operator_choice()
	 _local choice << .items[:operation_choice]
	 choice.text_items << items << _self.operation_items
	 _local op << _if .operator _is _unset
		      _then
			      >> items[1][1]
		      _else
			      >> .operator
		      _endif
	 choice.rwan_value_with_notify << op
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.operation_changed(value)
	.operator << value
	_self.update_image()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.update_image()
	_local op << .items[:operation_choice].value
	_local img << smallworld_product.get_raster_image( :explain_ + op, _self.module_name )
	.items[:explain].image << img
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method spatial_filter_dialog.ok()
	_if .holder _is _unset
	_then 
		_local new_col << _self.construct_spatial_predicate()
		.parent_model.add_holder(.parent_model.new_holder(new_col,
								  .name))
	_else
		.holder.name << .name
		.holder.collection.update(.source_geom_name, .operator, .filter_holder.collection, .filter_geom_name)
		.parent_model.update_holder(.holder)
	_endif 
	_self.close()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.construct_spatial_predicate()
	_return .source_holder.collection.filter_by_geometry(.source_geom_name, .operator,
							     .filter_holder.collection, .filter_geom_name)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.operation_items
	_local _constant ops <<  {:interacting_with, :touching, :dividing, :overlaying, :overlapping, :within, :equal_to, :containing, :disjoint_from}
	_local items << rope.new()
	_for i_key _over ops.fast_elements()
	_loop
		items.add( {i_key, _self.message(i_key)} )
	_endloop
	_return items
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.default_image
	_return smallworld_product.get_raster_image( :explain_interacting_with, _self.module_name )
_endmethod
$
_pragma(classify_level=restricted, topic={analysis})
_private _method spatial_filter_dialog.manage_actions()
	_local has_name? << .name.default("") <> ""
	.items[:ok].enabled? << .readonly?.not _andif has_name? _andif .source_geom_name _isnt _unset _andif .filter_geom_name _isnt _unset

	.items[:source_geometry_choice] .enabled? << .readonly?.not
	.items[:filter_holder_choice].enabled? << .readonly?.not
	.items[:filter_geometry_choice].enabled? << .readonly?.not
	.items[:name].enabled? << .readonly?.not
	.items[:operation_choice].enabled? << .readonly?.not
_endmethod
$
