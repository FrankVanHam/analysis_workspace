#
#  This file is part of Analysis Workshop.
#
#  Analysis Workshop is free software: you can redistribute it and/or modify
#  it under the terms of the Lesser GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Analysis Workshop is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Analysis Workshop.  If not, see <http://www.gnu.org/licenses/>.
#

_package rwan
$

#remex(:predicate_filter_dialog)
$

_pragma(classify_level=restricted, topic={analysis})
##
## Dialog to create filtered collection on a predicate of a
## base collection. Lets the user construct a predicate using a
## query_predicate_component.
##
def_slotted_exemplar(:predicate_filter_dialog,
	{
		{:predicate_component, _unset},
		{:predicate,           _unset}
	},
	:base_dialog)
$

message_handler.new(:predicate_filter_dialog).add_uses(:model, :base_dialog)
$

_pragma(classify_level=restricted, topic={analysis})
_method predicate_filter_dialog.set_source_holder(workspace, source_holder)
	.workspace << workspace
	.source_holder << source_holder
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method predicate_filter_dialog.set_holder(workspace,
					   holder, source_holder, predicate)
	.workspace << workspace
	.holder << holder
	.source_holder << source_holder
	.source_geom_name << :fail
	
	.predicate << predicate
	.filter_holder << :fail
	.filter_geom_name << :fail
	.name << holder.name
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method predicate_filter_dialog.activate_in(container)
	container.top_frame.modality << :primary_modal
	_local rc << rowcol.new(container,_unset, 1, _unset, :style, :top_level,
				:col_alignment, :fill,
				:row_alignment, :fill,
				:row_resize_values, {0,0,100,0,0,0})
	_self.build_top_label(rc)
	_self.build_source_label(rc)
	_self.build_predicate_selection(rc)
	_self.build_name(rc)
	panel_separator.new(rc, :col_alignment, :fill)
	_self.build_buttons(rc)
	_return rc
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.build_source_label(container)
	_local rc << rowcol.new(container, _unset, 2, _unset, :style, :nested, :col_alignment, :fill)
	sw_label_item.new(rc, _self.message(:source_collection))
	sw_label_item.new(rc, .source_holder.name)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.build_predicate_selection(container)
	_local rc << rowcol.new(container, 1, _unset, _unset, :style, :nested,
				:col_alignment, :fill,
				:row_alignment, :fill)
	_local ace << .parent_model.ace
	.predicate_component << query_predicate_component.new( :query, _self, :ace, ace)
	.predicate_component.build_gui(rc)
	
	_local col << .source_holder.collection.expose()
	_local names << _self.physical_fields(col, ace)
	.predicate_component.set_collection(col,
					    :field_names,
					    names)
_endmethod
$
_pragma(classify_level=restricted, topic={analysis})
_method predicate_filter_dialog.on_activation()
	_self.initialise_predicate()
	_self.initialise_name()
	_super.on_activation()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.initialise_predicate()
	_if .predicate _isnt _unset
	_then 
		.predicate_component.set_predicate(.predicate)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.physical_fields(col, ace)
	_local all_names << ace.table_visible_field_names_with_defaults(
				    col.dataset.dataset_name,
				    col.name,
				    :browser )
	_local names << rope.new()
	_for i_name _over all_names.fast_elements()
	_loop
		_if _not col.field(i_name).is_geometry?
		_then
			names.add(i_name)
		_endif
	_endloop
	_return names
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method predicate_filter_dialog.ok()
	_local pred << _self.ensure_predicate()
	_if .holder _is _unset
	_then
		_local new_col << _self.construct_predicate(pred)
		.parent_model.add_holder(.parent_model.new_holder(new_col,
								  .name))
	_else
		.holder.name << .name
		.holder.collection.update(pred)
		.parent_model.update_holder(.holder)
	_endif 
	_self.close()
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.ensure_predicate()
	_local pred << .predicate_component.predicate()
	_if pred _is _unset
	_then
		_self.user_error(:please_supply_a_predicate)
	_endif
	_return pred
_endmethod
$


_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.construct_predicate(pred)
	_return .source_holder.collection.filter_by_predicate(pred)
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_private _method predicate_filter_dialog.manage_actions()
	_local has_name? << .name.default("") <> ""
	_local has_predicate? << .predicate_component.predicate() _isnt _unset
	.items[:ok].enabled? << .readonly?.not _andif has_predicate? _andif has_name?
	
	.items[:name].enabled? << .readonly?.not
	_if .readonly?
	_then
		.predicate_component.disable()
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={analysis})
_method query_predicate_component.disable()
	_local items << .items
	items[:field].enabled? << _false
	items[:operator].enabled? << _false
	items[:operand_combo].enabled? << _false
	items[:operand_text].enabled? << _false
	items[:operand_choice].enabled? << _false
	items[:parts].enabled? << _false 
	items[:add].enabled? << _false 
	items[:update].enabled? << _false 
	items[:remove_popup].enabled? << _false 
	items[:remove].enabled? << _false 
	items[:or].enabled? << _false 
	items[:clear].enabled? << _false 
_endmethod
$
